#!/usr/bin/env ruby
# frozen_string_literal: true

# Author: Bruce Tesar
# Command line program for running ODL on the languages of SL.

# The resolver adds <project>/lib to the $LOAD_PATH.
require_relative '../lib/odl/resolver'

require 'optparse'
require 'sl/system'
require 'sl/data'
require 'factorial_typology'
require 'otlearn/data_manip'
require 'otlearn/language_learning_factory'
require 'otlearn/language_learning_image_maker'
require 'otlearn/language_learning_runner'

# define variables for option values
list_options = false
para_bias_string = nil
lcomp_string = nil
tcomp_string = nil
out_dir = '.'  # default is current working directory

# define the allowed command line options
opts = OptionParser.new
opts.on('-p', '--para_bias BIAS', 'paradigmatic ranking bias')\
  { |val| para_bias_string = val }
opts.on('-l', '--lcomp TYPE', 'Learning compare type')\
  { |val| lcomp_string = val }
opts.on('-t', '--tcomp TYPE', 'Testing compare type')\
  { |val| tcomp_string = val }
opts.on('-o', '--out_dir DIR', 'output directory name')\
  { |val| out_dir = val }
opts.on('-h', '--help', 'list the command line options')\
  { list_options = true }

# parse the actual command line, and report any unused arguments
rest = opts.parse(ARGV)
puts "Unused arguments: #{rest.join(', ')}" unless rest.empty?

# If the "list options" option is specified, print out the options
# to STDOUT and exit (ignore any other options).
if list_options
  puts opts.to_s
  exit(0)
end

# TODO: relocate these methods to somewhere sharable.
# Checks if the provided argument is missing (nil). If it is,
# print an error message including the missing option,
# and exit with an error code.
def check_required_arg(arg, option_string)
  return unless arg.nil?

  puts "ERROR: missing command line option #{option_string}."
  puts 'To see all options, run: clodl -h'
  exit(1) # return failure error code
end

# Checks if the provided argument is one of the allowed values.
# If not, print an error message, and exit with an error code.
def check_arg_value(arg, values, option_string)
  return if values.member?(arg)

  puts "ERROR: invalid #{option_string} value #{arg}."
  puts "Value must be one of #{values.join(', ')}"
  exit(1) # return failure error code
end

bias_values = %w[all_high faith_low mark_low]
check_required_arg(para_bias_string, '--para_bias')
check_arg_value(para_bias_string, bias_values, '--para_bias')
# Prepend para_ to the bias, forming the name of the factory method.
para_bias = "para_#{para_bias_string}".to_sym

comp_type_values = %w[pool ctie consistent]
check_required_arg(lcomp_string, '--lcomp')
check_arg_value(lcomp_string, comp_type_values, '--lcomp')
# Prepend learn_ to the comp type, forming the name of the factory method.
lcomp_type = "learn_#{lcomp_string}".to_sym

check_required_arg(tcomp_string, '--tcomp')
check_arg_value(tcomp_string, comp_type_values, '--tcomp')
# Prepend test_ to the comp type, forming the name of the factory method.
tcomp_type = "test_#{tcomp_string}".to_sym

# Read the languages from the data file. If the data file doesn't
# exist in the current working directory, create a new one.
data_file = 'outputs_typology_1r1s.mar'
unless File.exist?(data_file)
  puts 'Regenerating the typology data file.'
  competition_list = SL.generate_competitions_1r1s
  ft_result = FactorialTypology.new(competition_list)
  lang_list = ft_result.factorial_typology
  File.open(data_file, 'wb') do |f|
    lang_list.each do |lang|
      outputs = OTLearn.convert_wl_pairs_to_learning_data(lang)
      Marshal.dump(["Lg#{lang.label}", outputs], f)
    end
  end
end

# Configure the learner factory and build the learner
factory = OTLearn::LanguageLearningFactory.new
factory.send(para_bias)
factory.send(lcomp_type)
factory.send(tcomp_type)
factory.system = SL::System.instance
learner = factory.build

# Run learning on all of the languages
puts 'Learning the SL typology.'
image_maker = OTLearn::LanguageLearningImageMaker.new
runner = OTLearn::LanguageLearningRunner.new(factory.system, learner,
                                             image_maker)
runner.prep_output_dir(out_dir, '*.csv')
runner.run_languages(data_file) do |label, outputs|
  result = runner.run(label, outputs)
  runner.write(result, out_dir)
  puts "#{label} not learned." unless result.learning_successful?
end
puts 'SL learning is finished.'
