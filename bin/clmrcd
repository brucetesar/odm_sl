#!/usr/bin/env ruby
# frozen_string_literal: true

# Author: Bruce Tesar
# Command line program for running MRCD on a file of competitions.

# The resolver adds <project>/lib to the $LOAD_PATH.
require_relative '../lib/odl/resolver'

require 'optparse'
require 'csv_input'
require 'otgeneric/comp_list_reader'
require 'otgeneric/winners_reader'
require 'otgeneric/system'
require 'ranking_bias_all_high'
require 'otlearn/ranking_bias_some_low'
require 'otlearn/faith_low'
require 'otlearn/mark_low'
require 'otlearn/mrcd'
require 'rcd_runner'
require 'ranker'
require 'compare_pool'
require 'compare_ctie'
require 'compare_consistency'
require 'loser_selector'
require 'loser_selector_from_gen'
require 'rcd_image_maker'

# define variables for option values
comp_filename = nil
winners_filename = nil
bias_value = nil
compare_option_value = nil
list_options = false

# define the allowed command line options
opts = OptionParser.new
opts.on('-c', '--comp_file FILENAME', 'Competitions filename')\
  { |val| comp_filename = val.strip }
opts.on('-w', '--winner_file FILENAME', 'Winners filename')\
  { |val| winners_filename = val.strip }
opts.on('-b', '--bias BIAS', 'ranking bias', '  fl = faith low',
        '  ml = mark low', '  ah = all high (DEFAULT)')\
  { |val| bias_value = val }
opts.on('-l', '--loser_selection TYPE', 'Type of loser selection',
        '  pool', '  ctie', '  consistent')\
  { |val| compare_option_value = val }
opts.on('-?', '-h', '--help', 'list the command line options')\
  { list_options = true }

# parse the actual command line, and report any unused arguments
rest = opts.parse(ARGV)
puts "Unused arguments: #{rest.join(', ')}" unless rest.empty?

# If the "list options" option is specified, print out the options
# to STDOUT and exit (ignore any other options).
if list_options
  puts opts.to_s
  exit
end

# If list options were not required, but a filename for the competitions
# was not provided with -c, inform the user that they must provide
# a filename, and exit.
if comp_filename.nil?
  puts 'A filename for the competitions must be given using option -c.'
  puts 'To see all options, run: clmrcd -h'
  exit
end

# If list options were not required, but a filename for the winners
# was not provided with -w, inform the user that they must provide
# a filename, and exit.
if winners_filename.nil?
  puts 'A filename for the winners must be given using option -w.'
  puts 'To see all options, run: clmrcd -h'
  exit
end

# Establish the ranking bias
ranking_bias = if bias_value == 'fl'
                 OTLearn::RankingBiasSomeLow.new(OTLearn::FaithLow.new)
               elsif bias_value == 'ml'
                 OTLearn::RankingBiasSomeLow.new(OTLearn::MarkLow.new)
               else
                 RankingBiasAllHigh.new
               end
rcd_runner = RcdRunner.new(ranking_bias)
ranker = Ranker.new(rcd_runner)

# Construct the comparer
comparer = if compare_option_value == 'pool'
             ComparePool.new(ranker)
           elsif compare_option_value == 'ctie'
             CompareCtie.new(ranker)
           elsif compare_option_value == 'consistent'
             CompareConsistency.new
           end
if comparer.nil?
  msg = 'Must specify a valid loser selection type'
  raise msg
end

# Read the competitions from the specified CSV file.
comp_content = CsvInput.new(comp_filename)
clreader = OTGeneric::CompListReader.new
comp_list = clreader.arrays_to_comp_list(comp_content.headers,
                                         comp_content.data)

# Read the winners form the specified CSV file.
winner_content = CsvInput.new(winners_filename)
wreader = OTGeneric::WinnersReader.new
wreader.competitions = comp_list
winner_list = wreader.convert_array_to_winners(winner_content.data)

# Construct Loser Selector
system = OTGeneric::System.new(comp_list)
basic_selector = LoserSelector.new(comparer)
loser_selector = LoserSelectorFromGen.new(system, basic_selector)

# Run MRCD
erc_list = ErcList.new(constraint_list: system.constraints)
mrcd_result = OTLearn::Mrcd.new(winner_list, erc_list, loser_selector)

# Print (to STDOUT) the consistency and the hierarchy itself.
if mrcd_result.consistent?
  puts 'Consistent'
else
  puts 'Inconsistent'
end
ercs = ErcList.new.add_all(mrcd_result.added_pairs)
rcd_result = rcd_runner.run_rcd(ercs)
puts rcd_result.hierarchy.to_s
image_maker = RcdImageMaker.new
puts image_maker.get_image(rcd_result).to_a.to_s
